(load "board.fas")
(load "result.fas")

(defparameter *size* 0)  ;size records the number of rows or columns of the current board
(defparameter filename "boardtest.txt")
(defparameter *score* 0)
(defparameter *nil-beads* 0)
;(setq *nil-beads* 0)
(defparameter *move-records* nil)
(defparameter *current-remove* nil)
(defparameter judge-legal nil)
(defparameter *timeelipsed* 0)
(defparameter addnill 0)

(defun human-mode ()
  (setf *score* 0)
  (setf *move-records* nil)
  (setf *current-remove* nil)
  (setq addnill 0)
  (setq *nil-beads* 0)
  (dotimes (i 100) 
    (format t "~A" "*"))
  (format t "~%Welcome to Player Mode!~%") 
  (dotimes (i 100) 
    (format t "~A" "*"))
  (princ "Level Selection")
  (princ "*Please indicate the board level by its initial character*")
  (format t "~%Easy-5*5 [e]~%Middle-7*7 [m]~%Hard-10*10~%Import...[i]~%")
  (setf level (read))
  (cond ((equal level 'e)
	 (progn (setq *size* 5)
		(setq filename "board1.txt")))
	((equal level 'm)
	 (progn (setq *size* 7)
		(setq filename "board4.txt")))
	((equal level 'h)
	 (progn (setq *size* 10)
		(setq filename "board6.txt")))
	(t (progn (setf result (boardimport))
                (setq filename (car result))
                (setq *size* (cadr result)))))
  (defparameter *board* (make-array (list *size* *size*)))
  (setf file (open filename))
  (dotimes (row *size*)
    (dotimes (col *size*)
      (setf (aref *board* row col) (read-char file)))
    (read-char file nil :eof))
  (close file)  ;boarddata is imported succefully
  (boarddraw)
  (loop while (gamenotover) do
    (setq judge-legal nil)
    (loop while (not judge-legal) do
       (setq *current-remove* nil) 
      (princ "Please make your move by [x y]:")
      (setq move-x (read) move-y (read))
      (setq judge-legal (and (integerp move-x) (integerp move-y) (movecheck move-x move-y))))
;     (legalmove move-x move-y (aref *board* (1- move-x) (1- move-y)))
   (push (list move-x move-y) *move-records*)
   (setq addnill (length *current-remove*))
   (loop while (> (length *current-remove*) 0) do
       (setq makenil-index (pop *current-remove*))
       (setf (aref *board* (car makenil-index) (cadr makenil-index)) nil))
;      (if (equal (length *current-remove*) 1) (push (car *current-remove*) *move-records*))
    (boardrefresh nil)
    (boarddraw)
    (incf *nil-beads* addnill)
    (resultrefresh addnill)
    (resulthint))
(resultoutput)
(return-from human-mode)
)

(defun gamenotover()
  (dotimes (j *size*)
    (dotimes (i *size*) 
	  (if (aref *board* i j)
	      (progn (setq counter 1 current (aref *board* i j))
		     (if (and (> i 0) (equal current (aref *board* (1- i) j)))
			 (incf counter))
		     (if (and (< j (1- *size*)) (equal current (aref *board* i (1+ j))))
			 (incf counter))
		     (if (and (< i (1- *size*)) (equal current (aref *board* (1+ i) j)))
			 (incf counter))
		     (if (and (> j 0) (equal current (aref *board* i (1- j))))
			 (incf counter))
		     (if (>= counter 3)
			 (return-from gamenotover T)))))))

(defun movecheck(m n)
  (if (or (< m 1) (> m *size*) (< n 1) (> n *size*))
      (progn (format t "~%Illigal Move: OUTBOUND!!~%")
	     (return-from movecheck nil))
      (progn (if (setf color (aref *board* (1- m) (1- n)))
        (progn (setf *current-remove* nil)
            (legalmove (1- m) (1- n) color)
            (if (setf value (< (list-length *current-remove*) 3))
                (format t "~%SORRY: LESS THAN 3 BEADS CONNECTED!!~%"))
            (return-from movecheck (not value)))
        (progn (format t "~%Illigal Move: NO BEAD SELECTED!!~%")
            (return-from movecheck nil))))))

(defun legalmove (lr lc color)
    (if (member (list lr lc) *current-remove* :test #'equal) (return-from legalmove) 
        (progn (push (list lr lc) *current-remove*)
        (if (and (> lr 0) (equal color (aref *board* (1- lr) lc)))
            (legalmove (1- lr) lc color))
        (if (and (< lr (1- *size*)) (equal color (aref *board* (1+ lr) lc)))
            (legalmove (1+ lr) lc color))
        (if (and (> lc 0) (equal color (aref *board* lr (1- lc))))
            (legalmove lr (1- lc) color))
        (if (and (< lc (1- *size*)) (equal color (aref *board* lr (1+ lc))))
            (legalmove lr (1+ lc) color)))))
